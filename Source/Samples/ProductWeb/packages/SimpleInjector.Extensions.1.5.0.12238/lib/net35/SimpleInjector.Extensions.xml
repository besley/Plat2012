<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimpleInjector.Extensions</name>
    </assembly>
    <members>
        <member name="T:SimpleInjector.Extensions.DecoratorExtensions">
            <summary>
            Extension methods for applying decorators.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">
             <summary>
             Ensures that the supplied <paramref name="decoratorType"/> decorator is returned, wrapping the 
             original registered <paramref name="serviceType"/>, by injecting that service type into the 
             constructor of the supplied <paramref name="decoratorType"/>. Multiple decorators may be applied 
             to the same <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and 
             non-generic service types.
             </summary>
             <remarks>
             <para>
             The <b>RegisterDecorator</b> method works by hooking onto the container's
             <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
             <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
             decoration of types that are resolved using unregistered type resolution. The
             <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">RegisterOpenGeneric</see>
             extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
             use <b>RegisterDecorator</b> on the same generic service type as <b>RegisterOpenGeneric</b>.
             </para>
             <para>
             Multiple decorators can be applied to the same service type. The order in which they are registered
             is the order they get applied in. This means that the decorator that gets registered first, gets
             applied first, which means that the next registered decorator, will wrap the first decorator, which
             wraps the original service type.
             </para>
             <para>
             The registered <paramref name="decoratorType"/> must have a single public constructor. Constructor
             injection will be used on that type, and although it may have many constructor arguments, it must
             have exactly one argument of the type of <paramref name="serviceType"/>, or an argument of type
             <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. An exception will be
             thrown when this is not the case.
             </para>
             <para>
             The registered <paramref name="decoratorType"/> may have a constructor with an argument of type
             <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. In this case, the
             will not inject the decorated <paramref name="serviceType"/> itself into the 
             <paramref name="decoratorType"/> instance, but it will inject a <see cref="T:System.Func`1"/> that allows
             creating instances of the decorated type, according to the lifestyle of that type. This enables
             more advanced scenarios, such as executing the decorated types on a different thread, or executing
             decorated instance within a certain scope (such as a lifetime scope).
             </para>
             </remarks>
             <example>
             The following example shows the definition of a generic <b>ICommandHandler&lt;T&gt;</b> interface,
             a <b>CustomerMovedCommandHandler</b> implementing that interface, and a 
             <b>ValidatorCommandHandlerDecorator&lt;T&gt;</b> that acts as a decorator for that interface.
             <code lang="cs"><![CDATA[
             using System.ComponentModel.DataAnnotations;
             using System.Diagnostics;
             using System.Linq;
             
             using Microsoft.VisualStudio.TestTools.UnitTesting;
             
             using SimpleInjector;
             using SimpleInjector.Extensions;
             
             public interface ICommandHandler<TCommand>
             {
                 void Handle(TCommand command);
             }
            
             public class CustomerMovedCommand
             {
                 [Required]
                 public int CustomerId { get; set; }
            
                 [Required]
                 public Address Address { get; set; }
             }
            
             public class CustomerMovedCommandHandler
                 : ICommandHandler<CustomerMovedCommand>
             {
                 public void Handle(CustomerMovedCommand command)
                 {
                     // some logic
                 }
             }
            
             // Decorator that validates commands before they get executed.
             public class ValidatorCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly Container container;
            
                 public ValidatorCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     Container container)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.container = container;
                 }
            
                 public void Handle(TCommand command)
                 {
                     this.Validate(command);
            
                     this.decoratedHandler.Handle(command);
                 }
            
                 private void Validate(TCommand command)
                 {
                     var validationContext =
                         new ValidationContext(command, this.container, null);
            
                     Validator.ValidateObject(command, validationContext);
                 }
             }
             
             // Decorator that measures the time it takes to execute a command.
             public class MonitoringCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly ILogger logger;
            
                 public MonitoringCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     ILogger logger)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.logger = logger;
                 }
            
                 public void Handle(TCommand command)
                 {
                     var watch = Stopwatch.StartNew();
            
                     this.decoratedHandler.Handle(command);
            
                     this.logger.Log(string.Format("{0} executed in {1} ms.",
                         command.GetType().Name, watch.ElapsedMilliseconds));
                 }
             }
             
             [TestMethod]
             public static void TestRegisterOpenGenericDecorator()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, DebugLogger>();
            
                 // Search the given assembly and register all concrete types that 
                 // implement ICommandHandler<TCommand>.
                 container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>),
                     typeof(ICommandHandler<>).Assembly);
            
                 // Wrap all ICommandHandler<TCommand> service types with a decorator
                 // that measures and logs the duration of that handler.
                 container.RegisterDecorator(typeof(ICommandHandler<>),
                     typeof(MonitoringCommandHandlerDecorator<>));
            
                 // Wrap all ICommandHandler<TCommand> types (in this case it will
                 // wrap the monitoring decorator), but only if the TCommand contains
                 // any properties.
                 container.RegisterDecorator(typeof(ICommandHandler<>),
                     typeof(ValidatorCommandHandlerDecorator<>), context =>
                     {
                         var commandType = context.ServiceType.GetGenericArguments()[0];
                         bool mustDecorate = commandType.GetProperties().Any();
                         return mustDecorate;
                     });
            
                 // Act
                 var handler = 
                     container.GetInstance<ICommandHandler<CustomerMovedCommand>>();
            
                 // Assert
                 Assert.IsInstanceOfType(handler, 
                     typeof(ValidatorCommandHandlerDecorator<CustomerMovedCommand>));
             }
             ]]></code>
             </example>
             <param name="container">The container to make the registrations in.</param>
             <param name="serviceType">The definition of the open generic service type that will
             be wrapped by the given <paramref name="decoratorType"/>.</param>
             <param name="decoratorType">The definition of the open generic decorator type that will
             be used to wrap the original service type.</param>
             <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
             <paramref name="serviceType"/>, or <paramref name="decoratorType"/> are null
             references.</exception>
             <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/>  is not
             an open generic type, when <paramref name="decoratorType"/> does not inherit from or implement 
             <paramref name="serviceType"/>, when <paramref name="decoratorType"/> does not
             have a single public constructor, or when <paramref name="decoratorType"/> does not
             contain a constructor that has exactly one argument of type 
             <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
             <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">
             <summary>
             Ensures that the supplied <paramref name="decoratorType"/> decorator is returned when the supplied
             <paramref name="predicate"/> returns <b>true</b>, wrapping the original registered 
             <paramref name="serviceType"/>, by injecting that service type into the constructor of the 
             supplied <paramref name="decoratorType"/>. Multiple decorators may be applied to the same 
             <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and non-generic 
             service types.
             </summary>
             <remarks>
             <para>
             The <b>RegisterOpenGenericDecorator</b> method works by hooking onto the container's
             <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
             <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
             decoration of types that are resolved using unregistered type resolution. The
             <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">RegisterOpenGeneric</see>
             extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
             use <b>RegisterOpenGenericDecorator</b> on the same service type as <b>RegisterOpenGeneric</b>.
             </para>
             <para>
             Multiple decorators can be applied to the same service type. The order in which they are registered
             is the order they get applied in. This means that the decorator that gets registered first, gets
             applied first, which means that the next registered decorator, will wrap the first decorator, which
             wraps the original service type.
             </para>
             <para>
             The registered <paramref name="decoratorType"/> must have a single public constructor. Constructor
             injection will be used on that type, and although it may have many constructor arguments, it must
             have exactly one argument of the type of <paramref name="serviceType"/>, or an argument of type
             <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. An exception will be
             thrown when this is not the case.
             </para>
             <para>
             The registered <paramref name="decoratorType"/> may have a constructor with an argument of type
             <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. In this case, the
             will not inject the decorated <paramref name="serviceType"/> itself into the 
             <paramref name="decoratorType"/> instance, but it will inject a <see cref="T:System.Func`1"/> that allows
             creating instances of the decorated type, according to the lifestyle of that type. This enables
             more advanced scenarios, such as executing the decorated types on a different thread, or executing
             decorated instance within a certain scope (such as a lifetime scope).
             </para>
             </remarks>
             <example>
             The following example shows the definition of a generic <b>ICommandHandler&lt;T&gt;</b> interface,
             a <b>CustomerMovedCommandHandler</b> implementing that interface, and a 
             <b>ValidatorCommandHandlerDecorator&lt;T&gt;</b> that acts as a decorator for that interface.
             <code lang="cs"><![CDATA[
             using System.ComponentModel.DataAnnotations;
             using System.Diagnostics;
             using System.Linq;
             
             using Microsoft.VisualStudio.TestTools.UnitTesting;
             
             using SimpleInjector;
             using SimpleInjector.Extensions;
             
             public interface ICommandHandler<TCommand>
             {
                 void Handle(TCommand command);
             }
            
             public class CustomerMovedCommand
             {
                 [Required]
                 public int CustomerId { get; set; }
            
                 [Required]
                 public Address Address { get; set; }
             }
            
             public class CustomerMovedCommandHandler
                 : ICommandHandler<CustomerMovedCommand>
             {
                 public void Handle(CustomerMovedCommand command)
                 {
                     // some logic
                 }
             }
            
             // Decorator that validates commands before they get executed.
             public class ValidatorCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly Container container;
            
                 public ValidatorCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     Container container)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.container = container;
                 }
            
                 public void Handle(TCommand command)
                 {
                     this.Validate(command);
            
                     this.decoratedHandler.Handle(command);
                 }
            
                 private void Validate(TCommand command)
                 {
                     var validationContext =
                         new ValidationContext(command, this.container, null);
            
                     Validator.ValidateObject(command, validationContext);
                 }
             }
             
             // Decorator that measures the time it takes to execute a command.
             public class MonitoringCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly ILogger logger;
            
                 public MonitoringCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     ILogger logger)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.logger = logger;
                 }
            
                 public void Handle(TCommand command)
                 {
                     var watch = Stopwatch.StartNew();
            
                     this.decoratedHandler.Handle(command);
            
                     this.logger.Log(string.Format("{0} executed in {1} ms.",
                         command.GetType().Name, watch.ElapsedMilliseconds));
                 }
             }
             
             [TestMethod]
             public static void TestRegisterOpenGenericDecorator()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, DebugLogger>();
            
                 // Search the given assembly and register all concrete types that 
                 // implement ICommandHandler<TCommand>.
                 container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>),
                     typeof(ICommandHandler<>).Assembly);
            
                 // Wrap all ICommandHandler<TCommand> service types with a decorator
                 // that measures and logs the duration of that handler.
                 container.RegisterOpenGenericDecorator(typeof(ICommandHandler<>),
                     typeof(MonitoringCommandHandlerDecorator<>));
            
                 // Wrap all ICommandHandler<TCommand> types (in this case it will
                 // wrap the monitoring decorator), but only if the TCommand contains
                 // any properties.
                 container.RegisterOpenGenericDecorator(typeof(ICommandHandler<>),
                     typeof(ValidatorCommandHandlerDecorator<>), context =>
                     {
                         var commandType = context.ServiceType.GetGenericArguments()[0];
                         bool mustDecorate = commandType.GetProperties().Any();
                         return mustDecorate;
                     });
            
                 // Act
                 var handler = 
                     container.GetInstance<ICommandHandler<CustomerMovedCommand>>();
            
                 // Assert
                 Assert.IsInstanceOfType(handler, 
                     typeof(ValidatorCommandHandlerDecorator<CustomerMovedCommand>));
             }
             ]]></code>
             </example>
             <param name="container">The container to make the registrations in.</param>
             <param name="serviceType">The definition of the open generic service type that will
             be wrapped by the given <paramref name="decoratorType"/>.</param>
             <param name="decoratorType">The definition of the open generic decorator type that will
             be used to wrap the original service type.</param>
             <param name="predicate">The predicate that determines whether the 
             <paramref name="decoratorType"/> must be applied to a service type.</param>
             <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
             <paramref name="serviceType"/>, <paramref name="decoratorType"/>, or
             <paramref name="predicate"/> are null references.</exception>
             <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not
             an open generic type, when <paramref name="decoratorType"/> does not inherit from or 
             implement <paramref name="serviceType"/>, when <paramref name="decoratorType"/>
             does not have a single public constructor, or when <paramref name="decoratorType"/> does 
             not contain a constructor that has exactly one argument of type 
             <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
             <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterSingleDecorator(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Ensures that a single instance of the supplied <paramref name="decoratorType"/> decorator is 
            returned, wrapping the original registered <paramref name="serviceType"/>, by injecting that 
            service type into the constructor of the supplied <paramref name="decoratorType"/>. Multiple 
            decorators may be applied to the same <paramref name="serviceType"/>. Decorators can be applied 
            to both open, closed, and non-generic service types.
            </summary>
            <remarks>
            <para>
            This method ensures that a single instance of the supplied <paramref name="decoratorType"/> is
            returned, no matter what the lifestyle of the wrapped service type is. Use with care, because the
            wrapped service type will also become a singleton. This method is especially useful when use for
            injecting <see cref="T:System.Func`1"/> factory methods, which will allow the wrapped service type to get
            it's own lifestyle back.
            </para>
            <para>
            Please see the <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">RegisterDecorator</see> method
            for more information.
            </para>
            </remarks>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/>, or <paramref name="decoratorType"/> are null
            references.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/>  is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or implement 
            <paramref name="serviceType"/>, when <paramref name="decoratorType"/> does not
            have a single public constructor, or when <paramref name="decoratorType"/> does not
            contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterSingleDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">
            <summary>
            Ensures that the supplied <paramref name="decoratorType"/> decorator is returned when the supplied
            <paramref name="predicate"/> returns <b>true</b>, wrapping the original registered 
            <paramref name="serviceType"/>, by injecting that service type into the constructor of the 
            supplied <paramref name="decoratorType"/>. Multiple decorators may be applied to the same 
            <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and non-generic 
            service types.
            </summary>
            <remarks>
            <para>
            This method ensures that a single instance of the supplied <paramref name="decoratorType"/> is
            returned, no matter what the lifestyle of the wrapped service type is. Use with care, because the
            wrapped service type will also become a singleton. This method is especially useful when use for
            injecting <see cref="T:System.Func`1"/> factory methods, which will allow the wrapped service type to get
            it's own lifestyle back.
            </para>
            <para>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">RegisterDecorator</see>
            method for more information.
            </para>
            </remarks>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <param name="predicate">The predicate that determines whether the 
            <paramref name="decoratorType"/> must be applied to a service type.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/>, <paramref name="decoratorType"/>, or
            <paramref name="predicate"/> are null references.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or 
            implement <paramref name="serviceType"/>, when <paramref name="decoratorType"/>
            does not have a single public constructor, or when <paramref name="decoratorType"/> does 
            not contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="T:SimpleInjector.Extensions.DecoratorPredicateContext">
            <summary>
            An instance of this type will be supplied to the <see cref="T:System.Predicate`1"/>
            delegate that is that is supplied to the 
            <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">RegisterDecorator</see>
            overload that takes this delegate. This type contains information about the decoration that is about
            to be applied and it allows users to examine the given instance to see whether the decorator should
            be applied or not.
            </summary>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.ServiceType">
            <summary>
            Gets the closed generic service type for which the decorator is about to be applied. The original
            service type will be returned, even if other decorators have already been applied to this type.
            </summary>
            <value>The closed generic service type.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.ImplementationType">
            <summary>
            Gets the type of the implementation that is created by the container and for which the decorator
            is about to be applied. The original implementation type will be returned, even if other decorators
            have already been applied to this type. Please not that the implementation type can not always be
            determined. In that case the closed generic service type will be returned.
            </summary>
            <value>The implementation type.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.AppliedDecorators">
            <summary>
            Gets the list of the types of decorators that have already been applied to this instance.
            </summary>
            <value>The applied decorators.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.Expression">
            <summary>
            Gets the current <see cref="P:SimpleInjector.Extensions.DecoratorPredicateContext.Expression"/> object that describes the intention to create a new
            instance with its currently applied decorators.
            </summary>
            <value>The current expression that is about to be decorated.</value>
        </member>
        <member name="T:SimpleInjector.Extensions.Decorators.IDecoratableEnumerable">
            <summary>
            An IDecoratableEnumerable is a special enumerable that can be used more efficiently by the container
            to apply decorators to, with the biggest noticable difference that the registered predicate, will be
            checked for each service in the collection.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.Decorators.DecoratorExpressionInterceptor">
            <summary>
            Hooks into the building process and adds a decorator if needed.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericArgumentFinder">
            <summary>
            Allows retrieving the concrete types of the generic type arguments of that must be used to create a
            closed generic implementation of a given open generic implementation, based on on the concrete
            arguments of the given closed base type.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping">
            <summary>
            A map containing a generic argument (such as T) and the concrete type (such as Int32) that it
            represents.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping.System#IEquatable{SimpleInjector#Extensions#GenericArgumentFinder#ArgumentMapping}#Equals(SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping)">
            <summary>Implements equality. Needed for doing LINQ distinct operations.</summary>
            <param name="other">The other to compare to.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping.GetHashCode">
            <summary>Overrides the default hash code. Needed for doing LINQ distinct operations.</summary>
            <returns>An 32 bit integer.</returns>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericArgumentFinder.TypeConstraintValidator">
            <summary>
            Allows validating an ArgumentMapping.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericDecoratorExtensions">
            <summary>
            Extension methods for applying generic decorators.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.GenericDecoratorExtensions.RegisterOpenGenericDecorator(SimpleInjector.Container,System.Type,System.Type)">
             <summary>
             Ensures that a closed generic version of the supplied <paramref name="openGenericDecorator"/> 
             decorator is returned, wrapping the original closed generic version of the registered
             <paramref name="openGenericServiceType"/>, by injecting that service type into the constructor
             of the supplied <paramref name="openGenericDecorator"/>. Multiple decorators may be applied to the
             same <paramref name="openGenericServiceType"/>.
             </summary>
             <remarks>
             <para>
             The <b>RegisterOpenGenericDecorator</b> method works by hooking onto the container's
             <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
             <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
             decoration of types that are resolved using unregistered type resolution. The
             <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">RegisterOpenGeneric</see>
             extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
             use <b>RegisterOpenGenericDecorator</b> on the same service type as <b>RegisterOpenGeneric</b>.
             </para>
             <para>
             Multiple decorators can be applied to the same service type. The order in which they are registered
             is the order they get applied in. This means that the decorator that gets registered first, gets
             applied first, which means that the next registered decorator, will wrap the first decorator, which
             wraps the original service type.
             </para>
             </remarks>
             <example>
             The following example shows the definition of a generic <b>ICommandHandler&lt;T&gt;</b> interface,
             a <b>CustomerMovedCommandHandler</b> implementing that interface, and a 
             <b>ValidatorCommandHandlerDecorator&lt;T&gt;</b> that acts as a decorator for that interface.
             <code lang="cs"><![CDATA[
             using System.ComponentModel.DataAnnotations;
             using System.Diagnostics;
             using System.Linq;
             
             using Microsoft.VisualStudio.TestTools.UnitTesting;
             
             using SimpleInjector;
             using SimpleInjector.Extensions;
             
             public interface ICommandHandler<TCommand>
             {
                 void Handle(TCommand command);
             }
            
             public class CustomerMovedCommand
             {
                 [Required]
                 public int CustomerId { get; set; }
            
                 [Required]
                 public Address Address { get; set; }
             }
            
             public class CustomerMovedCommandHandler
                 : ICommandHandler<CustomerMovedCommand>
             {
                 public void Handle(CustomerMovedCommand command)
                 {
                     // some logic
                 }
             }
            
             // Decorator that validates commands before they get executed.
             public class ValidatorCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly Container container;
            
                 public ValidatorCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     Container container)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.container = container;
                 }
            
                 public void Handle(TCommand command)
                 {
                     this.Validate(command);
            
                     this.decoratedHandler.Handle(command);
                 }
            
                 private void Validate(TCommand command)
                 {
                     var validationContext =
                         new ValidationContext(command, this.container, null);
            
                     Validator.ValidateObject(command, validationContext);
                 }
             }
             
             // Decorator that measures the time it takes to execute a command.
             public class MonitoringCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly ILogger logger;
            
                 public MonitoringCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     ILogger logger)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.logger = logger;
                 }
            
                 public void Handle(TCommand command)
                 {
                     var watch = Stopwatch.StartNew();
            
                     this.decoratedHandler.Handle(command);
            
                     this.logger.Log(string.Format("{0} executed in {1} ms.",
                         command.GetType().Name, watch.ElapsedMilliseconds));
                 }
             }
             
             [TestMethod]
             public static void TestRegisterOpenGenericDecorator()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, DebugLogger>();
            
                 // Search the given assembly and register all concrete types that 
                 // implement ICommandHandler<TCommand>.
                 container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>),
                     typeof(ICommandHandler<>).Assembly);
            
                 // Wrap all ICommandHandler<TCommand> service types with a decorator
                 // that measures and logs the duration of that handler.
                 container.RegisterOpenGenericDecorator(typeof(ICommandHandler<>),
                     typeof(MonitoringCommandHandlerDecorator<>));
            
                 // Wrap all ICommandHandler<TCommand> types (in this case it will
                 // wrap the monitoring decorator), but only if the TCommand contains
                 // any properties.
                 container.RegisterOpenGenericDecorator(typeof(ICommandHandler<>),
                     typeof(ValidatorCommandHandlerDecorator<>), c =>
                     {
                         var commandType = c.ServiceType.GetGenericArguments()[0];
                         bool mustDecorate = commandType.GetProperties().Any();
                         return mustDecorate;
                     });
            
                 // Act
                 var handler = 
                     container.GetInstance<ICommandHandler<CustomerMovedCommand>>();
            
                 // Assert
                 Assert.IsInstanceOfType(handler, 
                     typeof(ValidatorCommandHandlerDecorator<CustomerMovedCommand>));
             }
             ]]></code>
             </example>
             <param name="container">The container to make the registrations in.</param>
             <param name="openGenericServiceType">The definition of the open generic service type that will
             be wrapped by the given <paramref name="openGenericDecorator"/>.</param>
             <param name="openGenericDecorator">The definition of the open generic decorator type that will
             be used to wrap the original service type.</param>
             <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
             <paramref name="openGenericServiceType"/>, or <paramref name="openGenericDecorator"/> are null
             references.</exception>
             <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/>  is not
             an open generic type, when <paramref name="openGenericDecorator"/> does not inherit from or implement 
             <paramref name="openGenericServiceType"/>, when <paramref name="openGenericDecorator"/> does not
             have a single public constructor, or when <paramref name="openGenericDecorator"/> does not
             contain a constructor that has exactly one argument of type 
             <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.GenericDecoratorExtensions.RegisterOpenGenericDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext})">
             <summary>
             Ensures that a closed generic version of the supplied <paramref name="openGenericDecorator"/> 
             decorator is returned, wrapping the original closed generic version of the registered
             <paramref name="openGenericServiceType"/>, by injecting that service type into the constructor
             of the supplied <paramref name="openGenericDecorator"/>. Multiple decorators may be applied to the
             same <paramref name="openGenericServiceType"/>.
             </summary>
             <remarks>
             <para>
             The <b>RegisterOpenGenericDecorator</b> method works by hooking onto the container's
             <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
             <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
             decoration of types that are resolved using unregistered type resolution. The
             <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">RegisterOpenGeneric</see>
             extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
             use <b>RegisterOpenGenericDecorator</b> on the same service type as <b>RegisterOpenGeneric</b>.
             </para>
             <para>
             Multiple decorators can be applied to the same service type. The order in which they are registered
             is the order they get applied in. This means that the decorator that gets registered first, gets
             applied first, which means that the next registered decorator, will wrap the first decorator, which
             wraps the original service type.
             </para>
             </remarks>
             <example>
             The following example shows the definition of a generic <b>ICommandHandler&lt;T&gt;</b> interface,
             a <b>CustomerMovedCommandHandler</b> implementing that interface, and a 
             <b>ValidatorCommandHandlerDecorator&lt;T&gt;</b> that acts as a decorator for that interface.
             <code lang="cs"><![CDATA[
             using System.ComponentModel.DataAnnotations;
             using System.Diagnostics;
             using System.Linq;
             
             using Microsoft.VisualStudio.TestTools.UnitTesting;
             
             using SimpleInjector;
             using SimpleInjector.Extensions;
             
             public interface ICommandHandler<TCommand>
             {
                 void Handle(TCommand command);
             }
            
             public class CustomerMovedCommand
             {
                 [Required]
                 public int CustomerId { get; set; }
            
                 [Required]
                 public Address Address { get; set; }
             }
            
             public class CustomerMovedCommandHandler
                 : ICommandHandler<CustomerMovedCommand>
             {
                 public void Handle(CustomerMovedCommand command)
                 {
                     // some logic
                 }
             }
            
             // Decorator that validates commands before they get executed.
             public class ValidatorCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly Container container;
            
                 public ValidatorCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     Container container)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.container = container;
                 }
            
                 public void Handle(TCommand command)
                 {
                     this.Validate(command);
            
                     this.decoratedHandler.Handle(command);
                 }
            
                 private void Validate(TCommand command)
                 {
                     var validationContext =
                         new ValidationContext(command, this.container, null);
            
                     Validator.ValidateObject(command, validationContext);
                 }
             }
             
             // Decorator that measures the time it takes to execute a command.
             public class MonitoringCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly ILogger logger;
            
                 public MonitoringCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     ILogger logger)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.logger = logger;
                 }
            
                 public void Handle(TCommand command)
                 {
                     var watch = Stopwatch.StartNew();
            
                     this.decoratedHandler.Handle(command);
            
                     this.logger.Log(string.Format("{0} executed in {1} ms.",
                         command.GetType().Name, watch.ElapsedMilliseconds));
                 }
             }
             
             [TestMethod]
             public static void TestRegisterOpenGenericDecorator()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, DebugLogger>();
            
                 // Search the given assembly and register all concrete types that 
                 // implement ICommandHandler<TCommand>.
                 container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>),
                     typeof(ICommandHandler<>).Assembly);
            
                 // Wrap all ICommandHandler<TCommand> service types with a decorator
                 // that measures and logs the duration of that handler.
                 container.RegisterOpenGenericDecorator(typeof(ICommandHandler<>),
                     typeof(MonitoringCommandHandlerDecorator<>));
            
                 // Wrap all ICommandHandler<TCommand> types (in this case it will
                 // wrap the monitoring decorator), but only if the TCommand contains
                 // any properties.
                 container.RegisterOpenGenericDecorator(typeof(ICommandHandler<>),
                     typeof(ValidatorCommandHandlerDecorator<>), c =>
                     {
                         var commandType = c.ServiceType.GetGenericArguments()[0];
                         bool mustDecorate = commandType.GetProperties().Any();
                         return mustDecorate;
                     });
            
                 // Act
                 var handler = 
                     container.GetInstance<ICommandHandler<CustomerMovedCommand>>();
            
                 // Assert
                 Assert.IsInstanceOfType(handler, 
                     typeof(ValidatorCommandHandlerDecorator<CustomerMovedCommand>));
             }
             ]]></code>
             </example>
             <param name="container">The container to make the registrations in.</param>
             <param name="openGenericServiceType">The definition of the open generic service type that will
             be wrapped by the given <paramref name="openGenericDecorator"/>.</param>
             <param name="openGenericDecorator">The definition of the open generic decorator type that will
             be used to wrap the original service type.</param>
             <param name="predicate">The predicate that determines whether the 
             <paramref name="openGenericDecorator"/> must be applied to a service type.</param>
             <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
             <paramref name="openGenericServiceType"/>, <paramref name="openGenericDecorator"/>, or
             <paramref name="predicate"/> are null references.</exception>
             <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
             an open generic type, when <paramref name="openGenericDecorator"/> does not inherit from or 
             implement <paramref name="openGenericServiceType"/>, when <paramref name="openGenericDecorator"/>
             does not have a single public constructor, or when <paramref name="openGenericDecorator"/> does 
             not contain a constructor that has exactly one argument of type 
             <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext">
            <summary>
            An instance of this type will be supplied to the <see cref="T:System.Predicate`1"/>
            delegate that is that is supplied to the 
            <see cref="M:SimpleInjector.Extensions.GenericDecoratorExtensions.RegisterOpenGenericDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext})">RegisterOpenGenericDecorator</see>
            overload that takes this delegate. This type contains information about the decoration that is about
            to be applied and it allows users to examine the given instance to see whether the decorator should
            be applied or not.
            </summary>
        </member>
        <member name="P:SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext.ServiceType">
            <summary>
            Gets the closed generic service type for which the decorator is about to be applied. The original
            service type will be returned, even if other decorators have already been applied to this type.
            </summary>
            <value>The closed generic service type.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext.ImplementationType">
            <summary>
            Gets the type of the implementation that is created by the container and for which the decorator
            is about to be applied. The original implementation type will be returned, even if other decorators
            have already been applied to this type. Please not that the implementation type can not always be
            determined. In that case the closed generic service type will be returned.
            </summary>
            <value>The implementation type.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext.AppliedDecorators">
            <summary>
            Gets the list of the types of decorators that have already been applied to this instance.
            </summary>
            <value>The applied decorators.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext.Expression">
            <summary>
            Gets the current <see cref="P:SimpleInjector.Extensions.GenericDecoratorExtensions.PredicateContext.Expression"/> object that describes the intention to create a new
            instance with its currently applied decorators.
            </summary>
            <value>The current expression that is about to be decorated.</value>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericTypeBuilder">
            <summary>
            Helper class for building closed generic type for a given open generic type and a closed generic base.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericTypeBuilder.BuildResult">
            <summary>Result of the GenericTypeBuilder.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.Helpers">
            <summary>
            Helper methods for the extensions.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.Requires">
            <summary>
            Internal helper class for precondition validation.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.BatchRegistrationCallback">
            <summary>
            Represents the method that will called to register one or multiple concrete. non-generic
            <paramref name="implementations"/> of the given closed generic type 
            <paramref name="closedServiceType"/>.
            </summary>
            <param name="closedServiceType">The service type that needs to be registered.</param>
            <param name="implementations">One or more concrete types that implement the given 
            <paramref name="closedServiceType"/>.</param>
        </member>
        <member name="T:SimpleInjector.Extensions.AccessibilityOption">
            <summary>Defines the accessibility of the types to search.</summary>
        </member>
        <member name="F:SimpleInjector.Extensions.AccessibilityOption.AllTypes">
            <summary>Load both public as internal types from the given assemblies.</summary>
        </member>
        <member name="F:SimpleInjector.Extensions.AccessibilityOption.PublicTypesOnly">
            <summary>Only load publicly exposed types from the given assemblies.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods for registration many concrete types at
            once that implement the same open generic service types in the <see cref="T:SimpleInjector.Container"/>.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">
            <summary>
            Registers all concrete, non-generic, publicly exposed types in the given set of
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic, publicly exposed types in the given 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.AccessibilityOption,System.Reflection.Assembly[])">
            <summary>
            Registers  all concrete, non-generic types with the given <paramref name="accessibility"/> in the 
            given <paramref name="assemblies"/> that implement the given 
            <paramref name="openGenericServiceType"/> with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple types that implement the same closed generic 
            version of the given <paramref name="openGenericServiceType"/>.</exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.AccessibilityOption,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic types with the given <paramref name="accessibility"/> in the 
            given <paramref name="assemblies"/> that implement the given 
            <paramref name="openGenericServiceType"/> with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.BatchRegistrationCallback,System.Reflection.Assembly[])">
            <summary>
            Allows registration of all concrete, public, non-generic types in the given set of 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/>, 
            by supplying a <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each 
            found closed generic implementation of the given <paramref name="openGenericServiceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.BatchRegistrationCallback,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Allows registration of all concrete, public, non-generic types in the given set of 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/>, 
            by supplying a <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each 
            found closed generic implementation of the given <paramref name="openGenericServiceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.AccessibilityOption,SimpleInjector.Extensions.BatchRegistrationCallback,System.Reflection.Assembly[])">
            <summary>
            Allows registration of all concrete, non-generic types with the given 
            <paramref name="accessibility"/> in the given set of <paramref name="assemblies"/> that implement 
            the given <paramref name="openGenericServiceType"/>, by supplying a 
            <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each found closed generic 
            implementation of the given <paramref name="openGenericServiceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.AccessibilityOption,SimpleInjector.Extensions.BatchRegistrationCallback,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Allows registration of all concrete, non-generic types with the given 
            <paramref name="accessibility"/> in the given set of <paramref name="assemblies"/> that implement 
            the given <paramref name="openGenericServiceType"/>, by supplying a 
            <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each found closed generic 
            implementation of the given <paramref name="openGenericServiceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">
            <summary>
            Registers all concrete, non-generic, publicly exposed types in the given 
            <paramref name="assemblies"/> that implement the given 
            <paramref name="openGenericServiceType"/> with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic, publicly exposed types in the given 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.AccessibilityOption,System.Reflection.Assembly[])">
            <summary>
            Registers  all concrete, non-generic types with the given <paramref name="accessibility"/> in the 
            given <paramref name="assemblies"/> that implement the given 
            <paramref name="openGenericServiceType"/> with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple types that implement the same closed generic 
            version of the given <paramref name="openGenericServiceType"/>.</exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.AccessibilityOption,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic types with the given <paramref name="accessibility"/> in the 
            given <paramref name="assemblies"/> that implement the given 
            <paramref name="openGenericServiceType"/> with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Type[])">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.BatchRegistrationCallback,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Allows registration of all supplied <paramref name="typesToRegister"/> by a closed generic 
            definition of the given <paramref name="openGenericServiceType"/>, by supplying a 
            <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each found closed generic 
            implementation.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="typesToRegister"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Type[])">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(System.Type,System.Reflection.Assembly[])">
            <summary>
            Returns all public types from the supplied <paramref name="assemblies"/> that implement or inherit
            from the supplied <paramref name="openGenericServiceType"/>.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the
            registration.
            </remarks>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Returns all public types from the supplied <paramref name="assemblies"/> that implement or inherit
            from the supplied <paramref name="openGenericServiceType"/>.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the registration.
            </remarks>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(System.Type,SimpleInjector.Extensions.AccessibilityOption,System.Reflection.Assembly[])">
            <summary>
            Returns all types from the supplied <paramref name="assemblies"/> that implement or inherit
            from the supplied <paramref name="openGenericServiceType"/>.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), AccessibilityOption.PublicTypesOnly,
                    typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the
            registration.
            </remarks>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(System.Type,SimpleInjector.Extensions.AccessibilityOption,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Returns all types from the supplied <paramref name="assemblies"/> that implement or inherit
            from the supplied <paramref name="openGenericServiceType"/>.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>.
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), AccessibilityOption.PublicTypesOnly, 
                    typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the registration.
            </remarks>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="accessibility">Defines which types should be used from the given assemblies.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Thrown when 
            <paramref name="accessibility"/> contains an invalid value.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="T:SimpleInjector.Extensions.NonGenericRegistrationsExtensions">
            <summary>
            Extension methods with non-generic method overloads.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterSingle(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Registers that the same instance of type <paramref name="implementation"/> will be returned every 
            time a <paramref name="serviceType"/> type is requested. If <paramref name="serviceType"/> and
            <paramref name="implementation"/> represent the same type, the type is registered by itself.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="implementation">The actual type that will be returned when requested.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/> or <paramref name="implementation"/> are null references (Nothing in
            VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="implementation"/> is
            no sub type from <paramref name="serviceType"/>, or when one of them represents an open generic
            type.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterSingle(SimpleInjector.Container,System.Type,System.Func{System.Object})">
            <summary>
            Registers the specified delegate that allows constructing a single <paramref name="serviceType"/> 
            instance. The container will call this delegate at most once during the lifetime of the application.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="instanceCreator">The delegate that will be used for creating that single instance.</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> represents an open
            generic type.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/> or <paramref name="instanceCreator"/> are null references (Nothing in
            VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterSingle(SimpleInjector.Container,System.Type,System.Object)">
            <summary>
            Registers a single instance. This <paramref name="instance"/> must be thread-safe.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="instance">The instance to register.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/> or <paramref name="instance"/> are null references (Nothing in
            VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="instance"/> is
            no sub type from <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.Register(SimpleInjector.Container,System.Type)">
            <summary>
            Registers that a new instance of <paramref name="concreteType"/> will be returned every time it 
            is requested (transient).
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="concreteType">The concrete type that will be registered.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/> or 
            <paramref name="concreteType"/> are null references (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="concreteType"/> represents an 
            open generic type or is a type that can not be created by the container.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.Register(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Registers that a new instance of <paramref name="implementation"/> will be returned every time a
            <paramref name="serviceType"/> is requested. If <paramref name="serviceType"/> and 
            <paramref name="implementation"/> represent the same type, the type is registered by itself.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="implementation">The actual type that will be returned when requested.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/> or <paramref name="implementation"/> are null references (Nothing in
            VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="implementation"/> is
            no sub type from <paramref name="serviceType"/>, or one of them represents an open generic type.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.Register(SimpleInjector.Container,System.Type,System.Func{System.Object})">
            <summary>
            Registers the specified delegate that allows returning instances of <paramref name="serviceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="instanceCreator">The delegate that will be used for creating new instances.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/> or <paramref name="instanceCreator"/> are null references (Nothing in
            VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> represents an
            open generic type.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterAll``1(SimpleInjector.Container,System.Type[])">
            <summary>
            Registers an collection of <paramref name="serviceTypes"/>, which instances will be resolved when
            enumerating the set returned when a collection of <typeparamref name="TService"/> objects is 
            requested. On enumeration the container is called for each type in the list.
            </summary>
            <typeparam name="TService">The base type or interface for elements in the collection.</typeparam>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceTypes">The collection of <see cref="T:System.Type"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/> or 
            <paramref name="serviceTypes"/> are null references (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceTypes"/> contains a null
            (Nothing in VB) element, a generic type definition, or the <typeparamref name="TService"/> is
            not assignable from one of the given <paramref name="serviceTypes"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterAll``1(SimpleInjector.Container,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers a collection of instances of <paramref name="serviceTypes"/> to be returned when
            a collection of <typeparamref name="TService"/> objects is requested.
            </summary>
            <typeparam name="TService">The base type or interface for elements in the collection.</typeparam>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceTypes">The collection of <see cref="T:System.Type"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/> or 
            <paramref name="serviceTypes"/> are null references (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceTypes"/> contains a null
            (Nothing in VB) element, a generic type definition, or the <typeparamref name="TService"/> is
            not assignable from one of the given <paramref name="serviceTypes"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterAll(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers an collection of <paramref name="serviceTypes"/>, which instances will be resolved when
            enumerating the set returned when a collection of <paramref name="serviceType"/> objects is 
            requested. On enumeration the container is called for each type in the list.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface for elements in the collection.</param>
            <param name="serviceTypes">The collection of <see cref="T:System.Type"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/>, or <paramref name="serviceTypes"/> are null references
            (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceTypes"/> contains a null
            (Nothing in VB) element, a generic type definition, or the <paramref name="serviceType"/> is
            not assignable from one of the given <paramref name="serviceTypes"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.NonGenericRegistrationsExtensions.RegisterAll(SimpleInjector.Container,System.Type,System.Collections.IEnumerable)">
            <summary>
            Registers a <paramref name="collection"/> of elements of type <paramref name="serviceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The base type or interface for elements in the collection.</param>
            <param name="collection">The collection of items to register.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/>,
            <paramref name="serviceType"/> or <paramref name="collection"/> are null references (Nothing in
            VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> represents an
            open generic type.</exception>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericRegistrationExtensions">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods for registration of open generic service
            types in the <see cref="T:SimpleInjector.Container"/>.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Registers that a new instance of <paramref name="openGenericImplementation"/> will be returned 
            every time a <paramref name="openGenericServiceType"/> is requested.
            </summary>
            <example>
            The following example shows the definition of a generic <b>IValidator&lt;T&gt;</b> interface
            and, a <b>NullValidator&lt;T&gt;</b> implementation and a specific validator for Orders.
            The registration ensures a <b>OrderValidator</b> is returned when a 
            <b>IValidator&lt;Order&gt;</b> is requested. For all requests for a 
            <b>IValidator&lt;T&gt;</b> other than a <b>IValidator&lt;Order&gt;</b>, an 
            implementation of <b>NullValidator&lt;T&gt;</b> will be returned.
            <code lang="cs"><![CDATA[
            public interface IValidator<T>
            { 
                void Validate(T instance);
            }
            
            public class NullValidator<T> : IValidator<T>
            {
                public void Validate(T instance)
                {
                }
            }
            
            public class OrderValidator : IValidator<Order>
            {
                public void Validate(Order instance)
                {
                    if (instance.Total < 0)
                    {
                        throw new ValidationException("Total can not be negative.");
                    }
                }
            }
            
            [TestMethod]
            public static void TestRegisterOpenGeneric()
            {
                // Arrange
                var container = new Container();
                
                container.Register<IValidator<Order>, OrderValidator>();
                container.RegisterOpenGeneric(typeof(IValidator<>), typeof(NullValidator<>));
                
                // Act
                var orderValidator = container.GetInstance<IValidator<Order>>();
                var customerValidator = container.GetInstance<IValidator<Customer>>();
                var productValidator = container.GetInstance<IValidator<Product>>();
            
                // Assert
                Assert.IsInstanceOfType(orderValidator, typeof(OrderValidator));
                Assert.IsInstanceOfType(customerValidator, typeof(NullValidator<Customer>));
                Assert.IsInstanceOfType(productValidator, typeof(NullValidator<Product>));
            }
            ]]></code>
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="openGenericImplementation">The definition of the open generic implementation type
            that will be returned when a <paramref name="openGenericServiceType"/> is requested.</param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterSingleOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Registers that the same instance of <paramref name="openGenericImplementation"/> will be returned 
            every time a <paramref name="openGenericServiceType"/> is requested.
            </summary>
            <example>
            The following example shows the definition of a generic <b>IValidator&lt;T&gt;</b> interface
            and, a <b>NullValidator&lt;T&gt;</b> implementation and a specific validator for Orders.
            The registration ensures a <b>OrderValidator</b> is returned when a 
            <b>IValidator&lt;Order&gt;</b> is requested. For all requests for a 
            <b>IValidator&lt;T&gt;</b> other than a <b>IValidator&lt;Order&gt;</b>, an 
            implementation of <b>NullValidator&lt;T&gt;</b> will be returned.
            <code lang="cs"><![CDATA[
            public interface IValidator<T>
            { 
                void Validate(T instance);
            }
            
            public class NullValidator<T> : IValidator<T>
            {
                public void Validate(T instance)
                {
                }
            }
            
            public class OrderValidator : IValidator<Order>
            {
                public void Validate(Order instance)
                {
                    if (instance.Total < 0)
                    {
                        throw new ValidationException("Total can not be negative.");
                    }
                }
            }
            
            [TestMethod]
            public static void TestRegisterOpenGeneric()
            {
                // Arrange
                var container = new Container();
                
                container.RegisterSingle<IValidator<Order>, OrderValidator>();
                container.RegisterSingleOpenGeneric(typeof(IValidator<>), typeof(NullValidator<>));
                
                // Act
                var orderValidator = container.GetInstance<IValidator<Order>>();
                var customerValidator = container.GetInstance<IValidator<Customer>>();
                var productValidator = container.GetInstance<IValidator<Product>>();
            
                // Assert
                Assert.IsInstanceOfType(orderValidator, typeof(OrderValidator));
                Assert.IsInstanceOfType(customerValidator, typeof(NullValidator<Customer>));
                Assert.IsInstanceOfType(productValidator, typeof(NullValidator<Product>));
            }
            ]]></code>
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances..</param>
            <param name="openGenericImplementation">The definition of the open generic implementation type
            that will be returned when a <paramref name="openGenericServiceType"/> is requested.</param>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.TransientOpenGenericResolver">
            <summary>Resolves a given open generic type as transient.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.OpenGenericResolver">
            <summary>Resolves a given open generic type.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.SingleOpenGenericResolver">
            <summary>Resolves a given open generic type as singleton.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.StringResources">
            <summary>Internal helper for string resources.</summary>
        </member>
    </members>
</doc>
