<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimpleInjector</name>
    </assembly>
    <members>
        <member name="T:SimpleInjector.ActivationException">
            <summary>
            The standard exception thrown when a container has an error in resolving an object.
            </summary>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class.
            </summary>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class with a specified error 
            message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class with a specified error 
            message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">
            The error message that explains the reason for the exception. 
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception, or a null reference (Nothing in Visual 
            Basic) if no inner exception is specified. 
            </param>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception 
            being thrown. 
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or 
            destination. 
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null. 
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or hresult is zero (0). 
            </exception>
        </member>
        <member name="T:SimpleInjector.Advanced.AdvancedExtensions">
            <summary>
            Extension methods for enable advanced scenarios.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.IsLocked(SimpleInjector.Container)">
            <summary>
            Determines whether the specified container is locked making any new registrations. The container
            is automatically locked when <see cref="M:SimpleInjector.Container.GetInstance(System.Type)">GetInstance</see> is called for the
            first time.
            </summary>
            <param name="container">The container.</param>
            <returns>
              <c>true</c> if the specified container is locked; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:SimpleInjector.Advanced.IConstructorInjectionBehavior">
            <summary>
            Defines the container's behavior for building an expression tree based on the supplied constructor of
            a given type.
            Set the <see cref="P:SimpleInjector.ContainerOptions.ConstructorInjectionBehavior">ConstructorInjectionBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IConstructorInjectionBehavior.BuildParameterExpression(System.Reflection.ParameterInfo)">
            <summary>
            Builds an <see cref="T:System.Linq.Expressions.Expression"/> for the supplied <paramref name="parameter"/>, based on the
            container's configuration.
            </summary>
            <param name="parameter">The parameter.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> that describes the intend of creating that 
            <paramref name="parameter"/>.</returns>
        </member>
        <member name="T:SimpleInjector.Advanced.IConstructorResolutionBehavior">
            <summary>
            Defines the container's behavior for finding a suitable constructor for the creation of a type.
            Set the <see cref="P:SimpleInjector.ContainerOptions.ConstructorResolutionBehavior">ConstructorResolutionBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IConstructorResolutionBehavior.GetConstructor(System.Type,System.Type)">
            <summary>
            Gets the given <paramref name="implementationType"/>'s constructor that can be used by the 
            container to create that instance.
            </summary>
            <param name="serviceType">Type of the abstraction that is requested.</param>
            <param name="implementationType">Type of the implementation to find a suitable constructor for.</param>
            <returns>
            The <see cref="T:System.Reflection.ConstructorInfo"/>.
            </returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when no suitable constructor could be found.</exception>
        </member>
        <member name="T:SimpleInjector.Advanced.IConstructorVerificationBehavior">
            <summary>
            Defines the container's behavior for verifying the constructor that will be picked by the
            <see cref="T:SimpleInjector.Advanced.IConstructorResolutionBehavior"/>.
            Set the <see cref="P:SimpleInjector.ContainerOptions.ConstructorVerificationBehavior">ConstructorVerificationBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IConstructorVerificationBehavior.Verify(System.Reflection.ParameterInfo)">
            <summary>Verifies the specified <paramref name="parameter"/>.</summary>
            <param name="parameter">The parameter.</param>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when the <paramref name="parameter"/> cannot be 
            used for auto wiring.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="parameter"/> is a
            null reference.</exception>
        </member>
        <member name="T:SimpleInjector.ContainerOptions">
            <summary>Configuration options for the <see cref="P:SimpleInjector.ContainerOptions.Container"/>.</summary>
            <example>
            The following example shows the typical usage of the <b>ContainerOptions</b> class.
            <code lang="cs"><![CDATA[
            var container = new Container(new ContainerOptions { AllowOverridingRegistrations = true });
            
            container.Register<ITimeProvider, DefaultTimeProvider>();
            
            // Replaces the previous registration of ITimeProvider
            container.Register<ITimeProvider, CustomTimeProvider>();
            ]]></code>
            Instead of applying the created <b>ContainerOptions</b> directly to the container's constructor, the
            options class can be stored in a local variable. This allows changing the behavior of the container
            during the initialization process.
            <code lang="cs"><![CDATA[
            var options = new ContainerOptions { AllowOverridingRegistrations = false };
            
            var container = new Container(options);
            
            BusinessLayerBootstrapper.Bootstrap(container);
            
            options.AllowOverridingRegistrations = true;
            
            // Replaces a possibly former registration of ITimeProvider
            container.Register<ITimeProvider, CustomTimeProvider>();
            ]]></code>
            </example>
        </member>
        <member name="M:SimpleInjector.ContainerOptions.#ctor">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.ContainerOptions"/> class.</summary>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.AllowOverridingRegistrations">
            <summary>
            Gets or sets a value indicating whether the container allows overriding registrations. The default
            is false.
            </summary>
            <value>The value indicating whether the container allows overriding registrations.</value>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.ConstructorResolutionBehavior">
            <summary>Gets or sets the constructor resolution behavior.</summary>
            <value>The constructor resolution behavior.</value>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.ConstructorVerificationBehavior">
            <summary>Gets or sets the constructor resolution behavior.</summary>
            <value>The constructor resolution behavior.</value>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.ConstructorInjectionBehavior">
            <summary>Gets or sets the constructor injection behavior.</summary>
            <value>The constructor injection behavior.</value>
        </member>
        <member name="T:SimpleInjector.CyclicDependencyValidator">
            <summary>
            Allows verifying whether a given type has a direct or indirect dependency on itself. Verifying is done
            by preventing recursive calls to a IInstanceProvider. An instance of this type is related to a single 
            instance of a IInstanceProvider. A RecursiveDependencyValidator instance checks a single 
            IInstanceProvider and therefore a single service type.
            </summary>
        </member>
        <member name="T:SimpleInjector.CyclicDependencyValidatorExtensions">
            <summary>
            Extension methods for the RecursiveDependencyValidator class.
            </summary>
        </member>
        <member name="T:SimpleInjector.InstanceProducers.InstanceProducer">
            <summary>Base class for producing instances.</summary>
        </member>
        <member name="T:SimpleInjector.IInstanceProducer">
            <summary>Contract for types that produce instances.</summary>
        </member>
        <member name="M:SimpleInjector.IInstanceProducer.GetInstance">
            <summary>Produces an instance.</summary>
            <returns>An instance. Will never return null.</returns>
            <exception cref="T:SimpleInjector.ActivationException">When the instance could not be retrieved or is null.</exception>
        </member>
        <member name="M:SimpleInjector.IInstanceProducer.BuildExpression">
            <summary>
            Builds an expression that expresses the intent to get an instance by the current producer.
            </summary>
            <returns>An Expression.</returns>
        </member>
        <member name="P:SimpleInjector.IInstanceProducer.ServiceType">
            <summary>Gets the service type for which this producer produces instances.</summary>
            <value>A <see cref="T:System.Type"/> instance.</value>
        </member>
        <member name="M:SimpleInjector.InstanceProducers.InstanceProducer.#ctor(System.Type)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.InstanceProducers.InstanceProducer"/> class.</summary>
            <param name="serviceType">The type of the service this instance will produce.</param>
        </member>
        <member name="M:SimpleInjector.InstanceProducers.InstanceProducer.BuildExpression">
            <summary>
            Builds an expression that expresses the intent to get an instance by the current producer.
            </summary>
            <returns>An Expression.</returns>
        </member>
        <member name="M:SimpleInjector.InstanceProducers.InstanceProducer.GetInstance">
            <summary>Produces an instance.</summary>
            <returns>An instance. Will never return null.</returns>
            <exception cref="T:SimpleInjector.ActivationException">When the instance could not be retrieved or is null.</exception>
        </member>
        <member name="M:SimpleInjector.InstanceProducers.InstanceProducer.BuildExpressionCore">
            <summary>
            Builds an expression that expresses the intent to get an instance by the current producer.
            </summary>
            <returns>An Expression.</returns>
        </member>
        <member name="P:SimpleInjector.InstanceProducers.InstanceProducer.ServiceType">
            <summary>Gets the service type for which this producer produces instances.</summary>
            <value>A <see cref="T:System.Type"/> instance.</value>
        </member>
        <member name="M:SimpleInjector.InstanceProducers.ExpressionResolutionInstanceProducer`1.#ctor(System.Linq.Expressions.Expression)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.InstanceProducers.ExpressionResolutionInstanceProducer`1"/> class.
            </summary>
            <param name="expression">The expression.</param>
        </member>
        <member name="M:SimpleInjector.InstanceProducers.FuncResolutionInstanceProducer`1.#ctor(System.Func{System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.InstanceProducers.FuncResolutionInstanceProducer`1"/> class.
            </summary>
            <param name="instanceCreator">The delegate that knows how to create that type.</param>
        </member>
        <member name="T:SimpleInjector.ExpressionBuiltEventArgs">
            <summary>
            Provides data for and interaction with the 
            <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event of 
            the <see cref="T:SimpleInjector.Container"/>. An observer can change the 
            <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/> property to change the registered type.
            </summary>
        </member>
        <member name="M:SimpleInjector.ExpressionBuiltEventArgs.#ctor(System.Type,System.Linq.Expressions.Expression)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.ExpressionBuiltEventArgs"/> class.</summary>
            <param name="registeredServiceType">Type of the registered service.</param>
            <param name="expression">The registered expression.</param>
        </member>
        <member name="P:SimpleInjector.ExpressionBuiltEventArgs.RegisteredServiceType">
            <summary>Gets the registered service type that is currently requested.</summary>
            <value>The registered service type that is currently requested.</value>
        </member>
        <member name="P:SimpleInjector.ExpressionBuiltEventArgs.Expression">
            <summary>Gets or sets the currently registered <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/>.</summary>
            <value>The current registration.</value>
            <exception cref="T:System.ArgumentNullException">Thrown when the supplied value is a null reference.</exception>
        </member>
        <member name="T:SimpleInjector.Container">
            <summary>
            The container. Create an instance of this type for registration of dependencies.
            </summary>
        </member>
        <member name="M:SimpleInjector.Container.Register``1">
            <summary>
            Registers that a new instance of <typeparamref name="TConcrete"/> will be returned every time it 
            is requested (transient). Note that calling this method is redundant in most scenarios, because
            the container will return a new instance for unregistered concrete types. Registration is needed
            when the security restrictions of the application's sandbox don't allow the container to create
            such type.
            </summary>
            <typeparam name="TConcrete">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <typeparamref name="TConcrete"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when the <typeparamref name="TConcrete"/> is a type
            that can not be created by the container.</exception>
        </member>
        <member name="M:SimpleInjector.Container.Register``2">
            <summary>
            Registers that a new instance of <typeparamref name="TImplementation"/> will be returned every time a
            <typeparamref name="TService"/> is requested.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <typeparamref name="TImplementation"/> 
            type is not a type that can be created by the container.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.Register``1(System.Func{``0})">
            <summary>
            Registers the specified delegate that allows returning instances of <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">The delegate that allows building or creating new instances.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="instanceCreator"/> is a null reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``1">
            <summary>
            Registers a single concrete instance that will be constructed using constructor injection. 
            This <typeparamref name="TConcrete"/> must be thread-safe.
            </summary>
            <typeparam name="TConcrete">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when 
            <typeparamref name="TConcrete"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when the <typeparamref name="TConcrete"/> is a type
            that can not be created by the container.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``2">
            <summary>
            Registers that the same instance of <typeparamref name="TImplementation"/> will be returned every 
            time a <typeparamref name="TService"/> is requested.
            </summary>
            <typeparam name="TService">
            The interface or base type that can be used to retrieve the instances.
            </typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <typeparamref name="TImplementation"/> 
            type is not a type that can be created by the container.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``1(``0)">
            <summary>Registers a single instance. This <paramref name="instance"/> must be thread-safe.</summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instance.</typeparam>
            <param name="instance">The instance to register.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="instance"/> is a null reference.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``1(System.Func{``0})">
            <summary>
            Registers the specified delegate that allows constructing a single instance of 
            <typeparamref name="TService"/>. This delegate will be called at most once during the lifetime of 
            the application.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">The delegate that allows building or creating this single
            instance.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when a 
            <paramref name="instanceCreator"/> for <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="instanceCreator"/> is a 
            null reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">
            <summary>
            Registers an <see cref="T:System.Action`1"/> delegate that runs after the creation of instances that
            implement or derive from the given <typeparamref name="TService"/>. Please note that only instances
            that are created by the container (using constructor injection) can be initialized this way.
            </summary>
            <typeparam name="TService">The type for which the initializer will be registered.</typeparam>
            <param name="instanceInitializer">The delegate that will be called after the instance has been
            constructed and before it is returned.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <paramref name="instanceInitializer"/> is a null reference.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered.</exception>
            <remarks>
            <para>
            Multiple <paramref name="instanceInitializer"/> delegates can be registered per 
            <typeparamref name="TService"/> and multiple initializers can be applied on a created instance,
            before it is returned. For instance, when registering a <paramref name="instanceInitializer"/>
            for type <see cref="T:System.Object"/>, the delegate will be called for every instance created by
            the container, which can be nice for debugging purposes.
            </para>
            <para>
            Note: Initializers are guaranteed to be executed in the order they are registered.
            </para>
            <para>
            The following example shows the usage of the 
            <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">RegisterInitializer</see> method:
            </para>
            <code lang="cs"><![CDATA[
            public interface ITimeProvider { DateTime Now { get; } }
            public interface ICommand { bool SendAsync { get; set; } }
            
            public abstract class CommandBase : ICommand
            {
                ITimeProvider Clock { get; set; }
                
                public bool SendAsync { get; set; }
            }
            
            public class ConcreteCommand : CommandBase { }
            
            [TestMethod]
            public static void TestRegisterInitializer()
            {
                // Arrange
                var container = new Container();
            
                container.Register<ICommand, ConcreteCommand>();
            
                // Configuring property injection for types that implement ICommand:
                container.RegisterInitializer<ICommand>(command =>
                {
                    command.SendAsync = true;
                });
            
                // Configuring property injection for types that implement CommandBase:
                container.RegisterInitializer<CommandBase>(command =>
                {
                    command.Clock = container.GetInstance<ITimeProvider>();
                });
                
                // Act
                var command = (ConcreteCommand)container.GetInstance<ICommand>();
            
                // Assert
                // Because ConcreteCommand implements both ICommand and CommandBase, 
                // both the initializers will have been executed.
                Assert.IsTrue(command.SendAsync);
                Assert.IsNotNull(command.Clock);
            }
            ]]></code>
            <para>
            The container does not use the type information of the requested service type, but it uses the 
            type information of the actual implementation to find all initialized that apply for that 
            type. This makes it possible to have multiple initializers to be applied on a single returned
            instance while keeping performance high.
            </para>
            <para>
            Registered initializers will only be applied to instances that are created by the container self
            (using constructor injection). Types that are newed up manually by supplying a 
            <see cref="T:System.Func`1"/> delegate to the container (using the 
            <see cref="M:SimpleInjector.Container.Register``1(System.Func{``0})"/> and 
            <see cref="M:SimpleInjector.Container.RegisterSingle``1(System.Func{``0})"/> methods) or registered as single instance
            (using <see cref="M:SimpleInjector.Container.RegisterSingle``1(``0)"/>) will not trigger initialization.
            When initialization of these instances is needed, this must be done manually, as can be seen in 
            the following example:
            <code lang="cs"><![CDATA[
            [TestMethod]
            public static void TestRegisterInitializer()
            {
                // Arrange
                int initializerCallCount = 0;
                
                var container = new Container();
                
                // Define a initializer for ICommand
                Action<ICommand> commandInitializer = command =>
                {
                    initializerCallCount++;
                });
                
                // Configuring that initializer.
                container.RegisterInitializer<ICommand>(commandInitializer);
                
                container.Register<ICommand>(() =>
                {
                    // Create a ConcreteCommand manually: will not be initialized.
                    var command = new ConcreteCommand("Data Source=.;Initial Catalog=db;");
                
                    // Run the initializer manually.
                    commandInitializer(command);
                
                    return command;
                });
                
                // Act
                var command = container.GetInstance<ICommand>();
            
                // Assert
                // The initializer will only be called once.
                Assert.AreEqual(1, initializerCallCount);
            }
            ]]></code>
            The previous example shows how a manually created instance can still be initialized. Try to
            prevent creating types manually, by changing the design of those classes. If possible, create a
            single public constructor that only contains dependencies that can be resolved.
            </para>
            </remarks>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Registers a dynamic collection of elements of type <typeparamref name="TService"/>. A call to
            <see cref="M:SimpleInjector.Container.GetAllInstances``1"/> will return the <paramref name="collection"/> itself, and updates 
            to the collection will be reflected in the result. If updates are allowed, make sure the 
            collection can be iterated safely if you're running a multi-threaded application.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="collection">The collection to register.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when a <paramref name="collection"/>
            for <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="collection"/> is a null
            reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll``1(``0[])">
            <summary>
            Registers a collection of singleton elements of type <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="singletons">The collection to register.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when a <paramref name="singletons"/>
            for <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="singletons"/> is a null
            reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when one of the elements of <paramref name="singletons"/>
            is a null reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.Verify">
            <summary>
            Verifies the <b>Container</b>. This method will call all registered delegates, 
            iterate registered collections and throws an exception if there was an error.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the registration of instances was
            invalid.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetInstance``1">
            <summary>Gets an instance of the given <typeparamref name="TService"/>.</summary>
            <typeparam name="TService">Type of object requested.</typeparam>
            <returns>The requested service instance.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetInstance(System.Type)">
            <summary>Gets an instance of the given <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type of object requested.</param>
            <returns>The requested service instance.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetAllInstances``1">
            <summary>
            Gets all instances of the given <typeparamref name="TService"/> currently registered in the container.
            </summary>
            <typeparam name="TService">Type of object requested.</typeparam>
            <returns>A sequence of instances of the requested TService.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetAllInstances(System.Type)">
            <summary>
            Gets all instances of the given <paramref name="serviceType"/> currently registered in the container.
            </summary>
            <param name="serviceType">Type of object requested.</param>
            <returns>A sequence of instances of the requested serviceType.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.System#IServiceProvider#GetService(System.Type)">
            <summary>Gets the service object of the specified type.</summary>
            <param name="serviceType">An object that specifies the type of service object to get.</param>
            <returns>A service object of type serviceType.  -or- null if there is no service object of type 
            <paramref name="serviceType"/>.</returns>
        </member>
        <member name="M:SimpleInjector.Container.GetRegistration(System.Type)">
            <summary>
            Gets the <see cref="T:SimpleInjector.InstanceProducers.InstanceProducer"/> for the given <paramref name="serviceType"/>. When no
            registration exists, the container will try creating a new producer. A producer can be created
            when the type is a concrete reference type, there is an <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/>
            event registered that acts on that type, or when the service type is an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Otherwise <b>null</b> (Nothing in VB) is returned.
            </summary>
            <remarks>
            <para>
            A call to this method locks the container. No new registrations can be made after a call to this 
            method.
            </para>
            <para>
            <b>Note:</b> This method is <i>not</i> guaranteed to always return the same <b>IInstanceProducer</b>
            instance for a given <see cref="T:System.Type"/>. It will however either always return <b>null</b> or
            always return a producer that is able to return the expected instance.
            </para>
            </remarks>
            <param name="serviceType">The <see cref="T:System.Type"/> that the returned instance producer should produce.</param>
            <returns>An <see cref="T:SimpleInjector.InstanceProducers.InstanceProducer"/> or <b>null</b> (Nothing in VB).</returns>
        </member>
        <member name="M:SimpleInjector.Container.GetRegistration(System.Type,System.Boolean)">
            <summary>
            Gets the <see cref="T:SimpleInjector.InstanceProducers.InstanceProducer"/> for the given <paramref name="serviceType"/>. When no
            registration exists, the container will try creating a new producer. A producer can be created
            when the type is a concrete reference type, there is an <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/>
            event registered that acts on that type, or when the service type is an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Otherwise <b>null</b> (Nothing in VB) is returned, or an exception is throw when
            <paramref name="throwOnFailure"/> is set to <b>true</b>.
            </summary>
            <remarks>
            <para>
            A call to this method locks the container. No new registrations can be made after a call to this 
            method.
            </para>
            <para>
            <b>Note:</b> This method is <i>not</i> guaranteed to always return the same <b>IInstanceProducer</b>
            instance for a given <see cref="T:System.Type"/>. It will however either always return <b>null</b> or
            always return a producer that is able to return the expected instance.
            </para>
            </remarks>
            <param name="serviceType">The <see cref="T:System.Type"/> that the returned instance producer should produce.</param>
            <param name="throwOnFailure">The indication whether the method should return null or throw
            an exception when the type is not registered.</param>
            <returns>An <see cref="T:SimpleInjector.InstanceProducers.InstanceProducer"/> or <b>null</b> (Nothing in VB).</returns>
        </member>
        <member name="M:SimpleInjector.Container.InjectProperties(System.Object)">
            <summary>
            Injects all public writable properties of the given <paramref name="instance"/> that have a type
            that can be resolved by this container instance.
            </summary>
            <param name="instance">The instance whos properties will be injected.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <paramref name="instance"/> is null (Nothing in VB).</exception>
            <exception cref="T:SimpleInjector.ActivationException">Throw when injecting properties on the given instance
            failed due to security constraints of the sandbox. This can happen when injecting properties
            on an internal type in a Silverlight sandbox, or when running in partial trust.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetInitializer``1">
            <summary>
            Builds up an <see cref="T:System.Action`1"/> delegate wrapping all <see cref="T:System.Action`1"/> delegates that
            are registered using <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">RegisterInitializer</see> and
            that apply to the given <typeparamref name="TService"/> (including delegates that are registered
            for interfaces <typeparamref name="TService"/> implements and base types that 
            <typeparamref name="TService"/> inherits from). <b>Null</b> will be returned when no delegates are
            registered that apply to this type.
            </summary>
            <typeparam name="TService">The type for with an initializer must be built.</typeparam>
            <returns>An <see cref="T:System.Action`1"/> delegate or <b>null</b>.</returns>
        </member>
        <member name="M:SimpleInjector.Container.LockContainer">
            <summary>Prevents any new registrations to be made to the container.</summary>
        </member>
        <member name="M:SimpleInjector.Container.#ctor">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.Container"/> class.</summary>
        </member>
        <member name="M:SimpleInjector.Container.#ctor(SimpleInjector.ContainerOptions)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.Container"/> class.</summary>
            <param name="options">The container options.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="options"/> is a null
            reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when supplied <paramref name="options"/> is an instance
            that already is supplied to another <see cref="T:SimpleInjector.Container"/> instance. Every container must get
            its own <see cref="T:SimpleInjector.ContainerOptions"/> instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetCurrentRegistrations">
            <summary>
            Returns an array with the current registrations. This list contains all explicitly registered
            types, and all implictly registered instances. Implicit registrations are  all concrete 
            unregistered types that have been requested, all types that have been resolved using
            unregistered type resolution (using the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event), and
            requested unregistered collections. Note that the result of this method may change over time, 
            because of these implicit registrations. Because of this, users should not depend on this method
            as a reliable source of resolving instances. This method is provided for debugging purposes.
            </summary>
            <remarks>
            <para>
            A call to this method locks the container. No new registrations can be made after a call to this 
            method.
            </para>
            <para>
            <b>Note:</b> This method is <i>not</i> guaranteed to always return the same <b>IInstanceProducer</b>
            instance for a given <see cref="T:System.Type"/>. It will however either always return <b>null</b> or
            always return a producer that is able to return the expected instance. Because of this, do not
            compare sets of instances returned by different calls to <see cref="M:SimpleInjector.Container.GetCurrentRegistrations"/>
            by reference. The way of comparing lists is by the actual type. The type of each instance is
            guaranteed to be unique in the returned list.
            </para>
            </remarks>
            <returns>An array of <see cref="T:SimpleInjector.InstanceProducers.InstanceProducer"/> instances.</returns>
        </member>
        <member name="M:SimpleInjector.Container.Equals(System.Object)">
            <summary>
            Determines whether the specified System.Object is equal to the current System.Object.
            </summary>
            <param name="obj">The System.Object to compare with the current System.Object.</param>
            <returns>
            True if the specified System.Object is equal to the current System.Object; otherwise, false.
            </returns>
        </member>
        <member name="M:SimpleInjector.Container.GetHashCode">
            <summary>Returns the hash code of the current instance.</summary>
            <returns>The hash code of the current instance.</returns>
        </member>
        <member name="M:SimpleInjector.Container.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the <see cref="T:SimpleInjector.Container"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the <see cref="T:SimpleInjector.Container"/>.
            </returns>
        </member>
        <member name="M:SimpleInjector.Container.GetType">
            <summary>Gets the <see cref="T:System.Type"/> of the current instance.</summary>
            <returns>The <see cref="T:System.Type"/> instance that represents the exact runtime 
            type of the current instance.</returns>
        </member>
        <member name="E:SimpleInjector.Container.ResolveUnregisteredType">
             <summary>
             Occurs when an instance of a type is requested that has not been registered, allowing resolution
             of unregistered types.
             </summary>
             <remarks>
             <para>
             The <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event is called by the container every time an 
             unregistered type is requested, allowing a developer to do unregistered type resolution. By calling the 
             <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})">Register</see> method on the
             <see cref="T:SimpleInjector.UnregisteredTypeEventArgs"/>, a delegate can be hooked to the container allowing the
             container to retrieve instances of the requested type, and preventing the 
             <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event from being called again for the same type.
             </para>
             <para>
             This event is called before resolving concrete unregistered types, allowing a developer to
             intercept the creation of concrete types.
             </para>
             <para>
             <b>Thread-safety:</b> Please note that the container will not ensure that the hooked delegates
             are executed only once. While the calls to <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> for a given type
             are finite (and will in most cases happen just once), a container can call the delegate multiple times
             and make parallel calls to the delegate. You must make sure that the code can be called multiple 
             times and is thread-safe.
             </para>
             </remarks>
             <example>
             The following example shows the usage of the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event:
             <code lang="cs"><![CDATA[
             public interface IValidator<T>
             {
                 void Validate(T instance);
             }
            
             // Implementation of the null object pattern.
             public class EmptyValidator<T> : IValidator<T>
             {
                 public void Validate(T instance)
                 {
                     // Does nothing.
                 }
             }
             
             [TestMethod]
             public void TestResolveUnregisteredType()
             {
                 // Arrange
                 var container = new Container();
             
                 // Register an EmptyValidator<T> to be returned when a IValidator<T> is requested:
                 container.ResolveUnregisteredType += (sender, e) =>
                 {
                     if (e.UnregisteredServiceType.IsGenericType &&
                         e.UnregisteredServiceType.GetGenericTypeDefinition() == typeof(IValidator<>))
                     {
                         var validatorType = typeof(EmptyValidator<>).MakeGenericType(
                             e.UnregisteredServiceType.GetGenericArguments());
                 
                         object emptyValidator = container.GetInstance(validatorType);
                 
                         // Register the instance as singleton.
                         e.Register(() => emptyValidator);
                     }
                 };
                 
                 // Act
                 var orderValidator = container.GetInstance<IValidator<Order>>();
                 var customerValidator = container.GetInstance<IValidator<Customer>>();
             
                 // Assert
                 Assert.IsInstanceOfType(orderValidator, typeof(EmptyValidator<Order>));
                 Assert.IsInstanceOfType(customerValidator, typeof(EmptyValidator<Customer>));
             }
             ]]></code>
             The example above registers a delegate that is fired every time an unregistered type is requested
             from the container. The delegate checks whether the requested type is a closed generic
             implementation of the <b>IValidator&lt;T&gt;</b> interface (such as 
             <b>IValidator&lt;Order&gt;</b> or <b>IValidator&lt;Customer&gt;</b>). In that case it
             will request the container for a concrete <b>EmptyValidator&lt;T&gt;</b> implementation that
             implements the given 
             <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType">UnregisteredServiceType</see>, and
             registers a delegate that will return this created instance. The <b>e.Register</b> call
             registers the method in the container, preventing the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> from
             being called again for the exact same service type, preventing any performance penalties.
             </example>
        </member>
        <member name="E:SimpleInjector.Container.ExpressionBuilt">
             <summary>
             Occurs after the creation of the <see cref="T:System.Linq.Expressions.Expression">Expression</see> 
             of a registered type, allowing the created 
             <see cref="T:System.Linq.Expressions.Expression">Expression</see>  to be replaced. Multiple delegates 
             may handle the same service type.
             </summary>
             <remarks>
             <para>
             The <see cref="E:SimpleInjector.Container.ExpressionBuilt"/> event is called by the container every time an registered type is 
             getting compiled, allowing a developer to change the way the type is created. The delegate that
             hooks to the <see cref="E:SimpleInjector.Container.ExpressionBuilt"/> event, can change the 
             <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/> property on the 
             <see cref="T:SimpleInjector.ExpressionBuiltEventArgs"/>, which allows changing the way the type is constructed.
             </para>
             <para>
             This event is called after unregistered types are resolved.
             </para>
             <para>
             <b>Thread-safety:</b> Please note that the container will not ensure that the hooked delegates
             are executed only once per service type. While the calls to <see cref="E:SimpleInjector.Container.ExpressionBuilt"/> for a given 
             type are finite (and will in most cases happen just once), a container can call the delegate 
             multiple times and make parallel calls to the delegate. You must make sure that the code can be 
             called multiple times and is thread-safe.
             </para>
             </remarks>
             <example>
             The following example shows the usage of the <see cref="E:SimpleInjector.Container.ExpressionBuilt"/> event:
             <code lang="cs"><![CDATA[
             public interface IValidator<T>
             {
                 void Validate(T instance);
             }
            
             public interface ILogger
             {
                 void Write(string message);
             }
            
             // Implementation of the decorator pattern.
             public class MonitoringValidator<T> : IValidator<T>
             {
                 private readonly IValidator<T> validator;
                 private readonly ILogger logger;
            
                 public MonitoringValidator(IValidator<T> validator, ILogger logger)
                 {
                     this.validator = validator;
                     this.logger = logger;
                 }
            
                 public void Validate(T instance)
                 {
                     this.logger.Write("Validating " + typeof(T).Name);
                     this.validator.Validate(instance);
                     this.logger.Write("Validated " + typeof(T).Name);
                 }
             }
            
             [TestMethod]
             public void TestExpressionBuilt()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, ConsoleLogger>();
                 container.Register<IValidator<Order>, OrderValidator>();
                 container.Register<IValidator<Customer>, CustomerValidator>();
            
                 // Intercept the creation of IValidator<T> instances and wrap them in a MonitoringValidator<T>:
                 container.ExpressionBuilt += (sender, e) =>
                 {
                     if (e.RegisteredServiceType.IsGenericType &&
                         e.RegisteredServiceType.GetGenericTypeDefinition() == typeof(IValidator<>))
                     {
                         var decoratorType = typeof(MonitoringValidator<>)
                             .MakeGenericType(e.RegisteredServiceType.GetGenericArguments());
            
                         // Wrap the IValidator<T> in a MonitoringValidator<T>.
                         e.Expression = Expression.New(decoratorType.GetConstructors()[0], new Expression[]
                         {
                             e.Expression,
                             container.GetRegistration(typeof(ILogger)).BuildExpression(),
                         });
                     }
                 };
            
                 // Act
                 var orderValidator = container.GetInstance<IValidator<Order>>();
                 var customerValidator = container.GetInstance<IValidator<Customer>>();
            
                 // Assert
                 Assert.IsInstanceOfType(orderValidator, typeof(MonitoringValidator<Order>));
                 Assert.IsInstanceOfType(customerValidator, typeof(MonitoringValidator<Customer>));
             }
             ]]></code>
             The example above registers a delegate that is fired every time the container compiles the
             expression for an registered type. The delegate checks whether the requested type is a closed generic
             implementation of the <b>IValidator&lt;T&gt;</b> interface (such as 
             <b>IValidator&lt;Order&gt;</b> or <b>IValidator&lt;Customer&gt;</b>). In that case it
             will changes the current <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/> with a new one that creates
             a new <b>MonitoringValidator&lt;T&gt;</b> that takes the current validator (and an <b>ILogger</b>)
             as an dependency.
             </example>
        </member>
        <member name="P:SimpleInjector.Container.Options">
            <summary>Gets the container options.</summary>
            <value>The <see cref="T:SimpleInjector.ContainerOptions"/> instance for this container.</value>
        </member>
        <member name="T:SimpleInjector.Container.InstanceInitializer">
            <summary>Wrapper for instance initializer Action delegates.</summary>
        </member>
        <member name="T:SimpleInjector.Helpers">
            <summary>
            Helper methods for the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Helpers.GetTypeHierarchyFor``1">
            <summary>Return a list of all base types T inherits, all interfaces T implements and T itself.</summary>
            <typeparam name="T">The type for get the type hierarchy from.</typeparam>
            <returns>A list of type objects.</returns>
        </member>
        <member name="T:SimpleInjector.StringResources">
            <summary>Internal helper for string resources.</summary>
        </member>
        <member name="T:SimpleInjector.UnregisteredTypeEventArgs">
            <summary>
            Provides data for and interaction with the 
            <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event of 
            the <see cref="T:SimpleInjector.Container"/>. An observer can check the 
            <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> to see whether the unregistered type can be handled. The
            <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})"/> method can be called to register a <see cref="T:System.Func`1"/> delegate 
            that allows creation of instances of the unregistered for this and future requests.
            </summary>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.#ctor(System.Type)">
            <summary>Initializes a new instance of the UnregisteredTypeEventArgs class.</summary>
            <param name="unregisteredServiceType">The unregistered service type.</param>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})">
            <summary>
            Registers a <see cref="T:System.Func`1"/> delegate that allows creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> for this and future requests. The delegate
            will be caches and future requests will directly call that delegate.
            </summary>
            <param name="instanceCreator">The delegate that allows creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="instanceCreator"/> is a
            null reference.</exception>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when multiple observers that have registered to
            the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event
            called this method for the same type.</exception>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Linq.Expressions.Expression)">
            <summary>
            Registers an <see cref="T:System.Linq.Expressions.Expression"/> that describes the creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> for this and future requests. The delegate
            will be caches and future requests will directly call that expression.
            </summary>
            <param name="expression">The expression that describes the creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="expression"/> is a
            null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the <paramref name="expression"/> is a
            not exactly of type <see cref="T:System.Func`1"/> where T equals the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.
            </exception>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when multiple observers that have registered to
            the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event
            called this method for the same type.</exception>
        </member>
        <member name="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType">
            <summary>Gets the unregistered service type that is currently requested.</summary>
            <value>The unregistered service type that is currently requested.</value>
        </member>
        <member name="P:SimpleInjector.UnregisteredTypeEventArgs.Handled">
            <summary>
            Gets a value indicating whether the event represented by this instance has been handled. 
            This property will return <b>true</b> when <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})"/> has been called on
            this instance.
            </summary>
            <value>The indication whether the event has been handled.</value>
        </member>
    </members>
</doc>
